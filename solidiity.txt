pragma solidity >=0.5.0 <0.6.0;

contract HelloWorld {

}

uint, int, string
+, -, /, *, power: **, %

unit[n] arrName;
uint[] dynamicArr;

function fName( uint memory _argName, uint _argName2) public/private/internal/external returns (string memory){

}

public: anyone
private: perticular contract only
internal: private+inherit contracts too
external: ONLY outside of contract

struct sName{
    uint varN;
    string varN2;
}
sName[] public structsName;
structsName.push();

event eName(uint x, uint y, uint result);
emit eName(_x, _y, result);

keccak256(abi.encodePacked(_str));???
////////

mapping (keydatatype => valuedatatype) mapName;
mapName[key] = value;
value = mapName[key];

msg.sender, gives address of th person/account who called the function

require, function will throw an error and stop executing if some condition is not true:
require(condition);

inheritance
contract subcontractName is parentcontractName{
}

importing
import "filepath.sol";

Storage: stored permanently on the blockchain
Memory: temporary, erased b/w external function calls

Interface (to interact with other contract)
looks like defining a contract, with a few differences. only declaring the functions we want to interact with.
contract InterfaceName{
    funtion functionName (uint arg) public return (type);
}
1: address tobecalledcontractaddress = 0xabdiuhfiuwehf32cd32;
2: InterfaceName InterfacePointer = InterfaceName(tobecalledcontractaddress);
3: InterfacePointer.functionName(arg);

take multiple return values with a function:
(a,b,,,e)=fName();

with strings, we have to compare their keccak256 hashes

a smart contract once uploaded to etherium can NOT be modified or changed under any conditions

modifiers:
keyword modifier instead of keyword function. Can't be called directly instead attach the modifier's name at the end of a function definition
When you call function, the code inside modifier executes first. Then when it hits the _; statement in modifier, it goes back and executes the code inside function.

Time:
now, return the current unix timestamp of the latest block (the number of seconds that have passed since January 1st 1970). The unix time

View function
dont cost gas when called externally cause no transaction created on blockchain.
If called internally from another function in the same contract, it will still cost gas. As the other function creates a transaction on Ethereum, and will still need to be verified from every node.
So view functions are only free when they're called externally.