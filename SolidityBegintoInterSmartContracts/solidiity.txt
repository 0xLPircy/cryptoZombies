pragma solidity >=0.5.0 <0.6.0;

contract HelloWorld {

}

uint, int, string
+, -, /, *, power: **, %

unit[n] arrName;
uint[] dynamicArr;

function fName( uint memory _argName, uint _argName2) public/private/internal/external view pure returns (string memory){

}

 function that doesn't read or modify the variables of the state is called a pure function,  pure tells us that not only does the function not save any data to the blockchain, but it also doesn't read any data from the blockchain.


public: anyone
private: perticular contract only
internal: private+inherit contracts too
external: ONLY outside of contract

struct sName{
    uint varN;
    string varN2;
}
sName[] public structsName;
structsName.push();

event eName(uint x, uint y, uint result);
emit eName(_x, _y, result);

keccak256(abi.encodePacked(_str));???
////////

mapping (keydatatype => valuedatatype) mapName;
mapName[key] = value;
value = mapName[key];

msg.sender, gives address of th person/account who called the function

require, function will throw an error and stop executing if some condition is not true:
require(condition);

inheritance
contract subcontractName is parentcontractName{
}

importing
import "filepath.sol";

Storage: stored permanently on the blockchain
Memory: temporary, erased b/w external function calls

Interface (to interact with other contract)
looks like defining a contract, with a few differences. only declaring the functions we want to interact with.
contract InterfaceName{
    funtion functionName (uint arg) public return (type);
}
1: address tobecalledcontractaddress = 0xabdiuhfiuwehf32cd32;
2: InterfaceName InterfacePointer = InterfaceName(tobecalledcontractaddress);
3: InterfacePointer.functionName(arg);

take multiple return values with a function:
(a,b,,,e)=fName();

with strings, we have to compare their keccak256 hashes

a smart contract once uploaded to etherium can NOT be modified or changed under any conditions

modifiers:
keyword modifier instead of keyword function. Can't be called directly instead attach the modifier's name at the end of a function definition
When you call function, the code inside modifier executes first. Then when it hits the _; statement in modifier, it goes back and executes the code inside function.

Time:
now, return the current unix timestamp of the latest block (the number of seconds that have passed since January 1st 1970). The unix time

View function
dont cost gas when called externally cause no transaction created on blockchain.
If called internally from another function in the same contract, it will still cost gas. As the other function creates a transaction on Ethereum, and will still need to be verified from every node.
So view functions are only free when they're called externally.

Arrays
uint[] memory values = new uint[](3); //in memory

Ownable contract taken from the OpenZeppelin Solidity library. OpenZeppelin is a library of secure and community-vetted smart contracts that you can use in your own DApps.

Address payable:
It is important to note that you cannot transfer Ether to an address unless that address is of type address payable. But the _owner variable is of type uint160, meaning that we must explicitly cast it to address payable.
address payable _owner = address(uint160(owner()));

ERC721
function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
//only sender can

and

function approve(address _approved, uint256 _tokenId) external payable;
function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
//both sender and reciever,  token's owner first calls approve with the address he wants to transfer to, and the _tokenID . 
The contract then stores who is approved to take a token, usually in a mapping (uint256 => address). 
Then, when the owner or the approved address calls transferFrom, the contract checks if that msg.sender is the owner or is approved by the owner to take the token, and if so it transfers the token to him.

SafeMath
OpenZeppelin has created a library called SafeMath to prevent underflos and overflows, ie max of uint8 =255 so its +1 is 0

library keyword â€” libraries are similar to contracts but with a few differences.
libraries allow us to use the using keyword, which automatically tacks on all of the library's methods to another data type

Assert
Similar to require, where it will throw an error if false. Require will refund gas when a function fails, assert will not.