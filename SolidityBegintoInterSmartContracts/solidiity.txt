pragma solidity >=0.5.0 <0.6.0;

contract HelloWorld {

}

uint, int, string
+, -, /, *, power: **, %

unit[n] arrName;
uint[] dynamicArr;

function fName( uint memory _argName, uint _argName2) public/private/internal/external view pure returns (string memory){

}

 function that doesn't read or modify the variables of the state is called a pure function,  pure tells us that not only does the function not save any data to the blockchain, but it also doesn't read any data from the blockchain.


public: anyone
private: perticular contract only
internal: private+inherit contracts too
external: ONLY outside of contract

struct sName{
    uint varN;
    string varN2;
}
sName[] public structsName;
structsName.push();

event eName(uint x, uint y, uint result);
emit eName(_x, _y, result);

keccak256(abi.encodePacked(_str));???
////////

mapping (keydatatype => valuedatatype) mapName;
mapName[key] = value;
value = mapName[key];

msg.sender, gives address of th person/account who called the function

require, function will throw an error and stop executing if some condition is not true:
require(condition);

inheritance
contract subcontractName is parentcontractName{
}

importing
import "filepath.sol";

Storage: stored permanently on the blockchain
Memory: temporary, erased b/w external function calls

Interface (to interact with other contract)
looks like defining a contract, with a few differences. only declaring the functions we want to interact with.
contract InterfaceName{
    funtion functionName (uint arg) public return (type);
}
1: address tobecalledcontractaddress = 0xabdiuhfiuwehf32cd32;
2: InterfaceName InterfacePointer = InterfaceName(tobecalledcontractaddress);
3: InterfacePointer.functionName(arg);

take multiple return values with a function:
(a,b,,,e)=fName();

with strings, we have to compare their keccak256 hashes

a smart contract once uploaded to etherium can NOT be modified or changed under any conditions

modifiers:
keyword modifier instead of keyword function. Can't be called directly instead attach the modifier's name at the end of a function definition
When you call function, the code inside modifier executes first. Then when it hits the _; statement in modifier, it goes back and executes the code inside function.

Time:
now, return the current unix timestamp of the latest block (the number of seconds that have passed since January 1st 1970). The unix time

View function
dont cost gas when called externally cause no transaction created on blockchain.
If called internally from another function in the same contract, it will still cost gas. As the other function creates a transaction on Ethereum, and will still need to be verified from every node.
So view functions are only free when they're called externally.

Arrays
uint[] memory values = new uint[](3); //in memory

Ownable contract taken from the OpenZeppelin Solidity library. OpenZeppelin is a library of secure and community-vetted smart contracts that you can use in your own DApps.

Address payable:
It is important to note that you cannot transfer Ether to an address unless that address is of type address payable. But the _owner variable is of type uint160, meaning that we must explicitly cast it to address payable.
address payable _owner = address(uint160(owner()));

ERC721
function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
//only sender can

and

function approve(address _approved, uint256 _tokenId) external payable;
function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
//both sender and reciever,  token's owner first calls approve with the address he wants to transfer to, and the _tokenID . 
The contract then stores who is approved to take a token, usually in a mapping (uint256 => address). 
Then, when the owner or the approved address calls transferFrom, the contract checks if that msg.sender is the owner or is approved by the owner to take the token, and if so it transfers the token to him.

SafeMath
OpenZeppelin has created a library called SafeMath to prevent underflos and overflows, ie max of uint8 =255 so its +1 is 0

library keyword â€” libraries are similar to contracts but with a few differences.
libraries allow us to use the using keyword, which automatically tacks on all of the library's methods to another data type

Assert
Similar to require, where it will throw an error if false. Require will refund gas when a function fails, assert will not.

Commenting
usually natspec, is used
 which looks like this:

/// @title A contract for basic math operations
/// @author H4XF13LD MORRIS ðŸ’¯ðŸ’¯ðŸ˜ŽðŸ’¯ðŸ’¯
/// @notice For now, this contract just adds a multiply function
contract Math {
  /// @notice Multiplies 2 numbers together
  /// @param x the first uint.
  /// @param y the second uint.
  /// @return z the product of (x * y)
  /// @dev This function does not currently check for overflows
  function multiply(uint x, uint y) returns (uint z) {
    // This is just a normal comment, and won't get picked up by natspec
    z = x * y;
  }
}
@title and @author are straightforward.
@notice explains to a user what the contract / function does. @dev is for explaining extra details to developers.
@param and @return are for describing what each parameter and return value of a function are for.
Note that you don't always have to use all of these tags for every function â€” all tags are optional. But at the very least, leave a @dev note explaining what each function does.




FRONT END
github se web3.min.js connected to an html file (can do npm i web3 but dk how that works rn)

Web3 Provider
Tells our code which node we should be talking to handle our reads and writes.
third-party service that makes your life easier so you don't need to maintain your own Ethereum node in order to provide a DApp for your users â€” Infura.
usage: var web3 = new Web3(new Web3.providers.WebsocketProvider("wss://mainnet.infura.io/ws"));

Metamask:
lets users securely manage their Ethereum accounts and private keys, and use these accounts to interact with websites that are using Web3.js. 
Metamask injects their web3 provider into the browser in the global JavaScript object web3. So your app can check to see if web3 exists, and if it does use web3.currentProvider as its provider.
usage: window.addEventListener('load', function() {

  // Checking if Web3 has been injected by the browser (Mist/MetaMask)
  if (typeof web3 !== 'undefined') {
    // Use Mist/MetaMask's provider
    web3js = new Web3(web3.currentProvider);
  } else {
    // Handle the case where the user doesn't have web3. Probably
    // show them a message telling them to install Metamask in
    // order to use our app.
  }

  // Now you can start your app & access web3js freely:
  startApp()

})